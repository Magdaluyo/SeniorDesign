\chapter{Technology Used and Design Rationale}

\section{Description}
In this chapter, we discuss the necessary devices and technology needed for this system and our reasoning for their choice in our design.

\section{Communication Protocols}
In the IoT world, there are a few communication protocols that we could use. In the following subsections, we go over the benefits and disadvantages of using each protocol.

\subsection{802.11 (Wi-Fi)}
802.11 is a common protocol with 802.11 access points present in many places today. It has high bandwidth at 11 Mbps and is supported by many devices. It is powerful and has moderate range between 30 and 100 meters. Unfortunately, this is a high power protocol which is not ideal for components in our system that will run on battery such as the doorbell and devices that may be used to notify the user. \cite{website:bluetooth-vs-wifi}. This is a huge disadvantage but it would be extremely easy to implement. Considering a Raspberry Pi, almost all the models come with 802.11 configurations built in.

    In our design, we decided to use this protocol in only broadcasting to devices connected to our system that will relay notifications to the user. Most likely these devices will have consistent power and will already be connected to the user’s WiFi network. Assuming a resident has a Wi-Fi router in his or her house, all notifications could be relayed through that. If this isn't the case, the Raspberry Pi can be configured to run as a Wi-Fi router using Hostapd. This would further increase the possible outreach to users as some may not be able to afford Wi-Fi routers. 

\subsection{802.15.1 (Bluetooth)}
802.15.1 is another common protocol. Many devices come with Bluetooth to provide low range, moderate bandwidth connections. The bandwidth is moderate at 800 kbps while also providing moderate power consumption. The range is low at about 5 to 30 meters which is not useful if components of our system are placed far away from our central gateway. While a huge disadvantage, Bluetooth is available in many devices today such as smartphones.

    In our design, we decided to use this protocol in broadcasting to devices connected to our system like 802.11 and for connecting a smartphone application to the gateway. The smartphone application would allow an average user to control the system as necessary for themselves. Although, a user will only be able to control the system if they are close to the gateway. With Bluetooth's moderate bandwidth, changes can be applied quickly.

\subsection{802.15.4 (Zigbee)}
802.15.4 is more commonly used in IoT applications. It is useful for it’s low power consumption and far range (about 100 meters). It has low bandwidth but that is not a problem for most IoT applications that may only require simple relays of information between devices. Most development in 802.15.4 uses Zigbee, a application layer protocol, that provides security and optimization for home automation. Zigbee is effective in making sure packets are not dropped and associating devices with each other. Bare 802.15.4 broadcasts data to a channel and doesn't worry about the end device receiving the data.
 
    In our design, we decided to only go with 802.15.4. Development with Zigbee is covered under the Zigbee Alliance which would require us applying into the alliance. Considering the scope of this project, this seemed like an unnecessary delay. Furthermore, we don’t need the benefits of Zigbee to show a proof of concept. We found that 802.15.4 would be best in broadcasting between the doorbell and the gateway. This provides good range and allows the doorbell to consume less power than other communication protocols. In this way, we can increase the lifetime of the doorbell and allow the gateway to be placed farther from the doorbell if necessary. Although, an actual implementation should use Zigbee in order to provide security and to make sure that all messages are received by the gateway.

\section{Hardware}
Our system consists of edge devices and a gateway. The edge devices are the doorbell and the devices relaying notifications to the user. The gateway is made up of a Raspberry Pi Zero W and an XBee. The gateway will receive a notification from the doorbell and will notify the other devices through a home network.

\subsection{Gateway}
The gateway consists of a Raspberry Pi Zero W and an XBee. XBee is a programmable module from DigiKey. The S1 variant can use either 802.15.4 or Zigbee depending on the firmware flashed. Furthermore, it uses serial Tx and Rx to communicate so it can be added easily to any module that has a serial port. The Raspberry Pi Zero W was favorable to us as it would make our development easier being a familiar Unix-based system and having a vast open-source community. Furthermore, it is low cost and the W variant comes with Bluetooth and WiFi. Using these protocols, we can communicate to various devices connected to a home network through an access point. It is also a small device at 2.6 x 1.2 x 0.6 inches making it an unobtrusive device in the home. It has plenty more power than we require but its open source environment would allow for better development for us and in the future. It would also allow a user with programming knowledge to configure the system to their wants. There are 26 GPIO pins available. A possible configuration would be to set the GPIO pins to also notify users from its location by the router. To connect the XBee to the Raspberry Pi Zero, a user can directly connect to the pins with jumper cables or use a shield to usb connection.

\subsection{Doorbell}
The doorbell was originally intended to be Texas Instruments’ SensorTag C2650. The SensorTag has the option of either using Bluetooth or 802.15.4, which can be configured by flashing different firmware. SensorTag comes with many sensors which we thought would be great for us to experiment with such as the motion sensor. It was also advertised to last for two years using a lithium coin battery. This is a huge advantage as we don’t want users to be changing the battery often for the device. While more expensive than we would like (\$30), the SensorTag c2650 could be a viable option with a greater amount of actions to benefit the resident.

    We eventually decided it was best to move away from SensorTag due to issues covered in a later chapter. Our solution became to use two XBees to communicate with each other. XBee is a powerful, encrypted module that can operate with any 3.3V pin of a small computer. We knew that two XBees would work so long as they had the same parameters flashed.  We verified this, using Digikey's XCTU software which allows us to flash parameters and debug the input. To accomplish this, we decided to use Arduino as the main processor for the doorbell. We used Arduino Uno for prototyping but Arduino Nano would be the best option in order to maintain a low power solution. Using an Arduino shield, interfacing with the XBee was simple using an XBee library from DigiKey. (Our design is implemented with the S1 variant. Different variants do not communicate with another variant, so it is important that both are the same.)
    
    The XBee has many parameters that can be flashed per the 802.15.4 specifications. Fortunately, an XBee out of the box will work with another XBee out of the box with no configuration. This could lead to security issues though. As this was not an important aspect in our project of building a proof of concept, we did not concern ourselves with this. We did change the broadcast address so it transmits to many channels. With the receiving XBee scanning those channels, we can improve reliability with sending packets. We may see some packets dropped if there is interference on a specific channel. Furthermore, we can improve the power consumption of the XBee by configuring the device to wake up on a trigger on any of the pins.
    
    For the doorbell, we also wanted a visitor to have feedback that the doorbell was pressed. A common occurrence in pressing a doorbell is hearing the doorbell chime, informing the visitor that the doorbell is working and has sent a notification to the resident. We decided that an LED pulse would accomplish this same effect. Using an Illuminated Momentary Pushbutton from Adafruit, we were able to simply accomplish this in our doorbell. Alternatively, a resident could configure the doorbell to be attached with a speaker if they so desired. Arduino has many configurable speakers that can be attached to their devices.

\subsection{Conneced Devices}
A Philips Hue LED strip was used to test the implementation. Although expensive, Philips Hue has well-designed devices with an open API for Raspberry Pi, known as PiHue, that makes it easy to integrate into the system. Since this is just a proof of concept, showing the system performance was a larger concern.

\section{Software Development}
Software consisted of C/C++, Python and Node-RED. The software was used in different ways in the system and is described in more detail in the following subsections.

\subsection{Doorbell Software}
The doorbell software is written in Arduino code which is based off of C/C++. The Arduino board can communicate to the XBee using the already available serial library. Since Arduino runs code continuously in a loop, the code waits for a trigger from the doorbell press. On press, the LED pulses to notify the visitor that the button is broadcasting. The XBee will send a broadcast. Any XBee with the same parameters in range will receive the packet.

\subsection{Gateway Software}
The gateway’s software comprised mostly of Node-RED. Created by IBM for IoT applications and written in Javascript, Node-RED uses flow programming to trigger nodes. Each node is a block that runs a process when triggered and provides an output that can trigger another node or end the flow. Using a ‘start-up-trigger’ node, the application will immediately start the flow when the Node-RED server starts. The flow will then wait to receive serial output from the XBee through the Pi’s Rx pin. When the node returns, the flow will split and notify all of the connected devices in the house each with their own respective nodes. To avoid unnecessary spawning of node processes and causing undefined behavior from doorbell spam, the flow waits for all nodes of notification devices to return. With the ‘wait-paths’ node, once all nodes return, the flow is repeated. For even better configuration, the individual nodes can be modified. Each is a .json object and has a few inputs that a script performs on.

Node-RED is also an open source software. This is beneficial because an open source community has already developed many nodes and may continue to develop more. For example, there are already a few Philips Hue nodes. More open API edge devices may have available nodes. And if there are none, a user with minimal programming knowledge could create their own node and make it available to other user and our system.

Unfortunately, there is some delay with Node-RED starting. The Raspberry Pi Zero is a weak computer. If the SD card is not fast or there are many processes, it will be slow. From booting up to the flow starting, we found that it took about 4 minutes before we could start using the system. This isn't favorable performance but ideally, it is only performed once. In the case of restarting the flow, that would take about a minute. Again, this is not favorable performance but it is a disadvantage of using a lower cost module. A user could decide to go with a more powerful Raspberry Pi and SD card if they so desire and the performance will greatly increase.

\subsection{Broadcasting Software}
With Raspberry Pi’s versatility as a Unix-based system, any programming language can be used to activate the connected devices. In our testing, the APIs were available in Python. With Node-RED, any script can be run using an ‘exec’ node. Furthermore, since Node-RED is open source, anyone can create nodes for use by creating a .json, .js, and .html file. Creating nodes are simple. With some technical knowledge, a growing network of nodes could be created for this application and may already be available for many devices.

Using Python or any scripting language also has a benefit in our system. We can easily modify the scripts when the resident desires to do so. Using the smartphone application, a user can modify settings of notification devices. By using a scripting language like python, we don't need to compile the code with every configuration. Furthermore, it would be unnecessary to restart the flow for Node-RED.